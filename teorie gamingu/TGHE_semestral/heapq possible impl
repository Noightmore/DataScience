#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

typedef struct {
    int node;
    int cost;
} Edge;

typedef struct {
    int size;
    int capacity;
    Edge* data;
} MinHeap;

MinHeap* create_min_heap(int capacity) {
    MinHeap* heap = malloc(sizeof(MinHeap));
    heap->size = 0;
    heap->capacity = capacity;
    heap->data = malloc(sizeof(Edge) * capacity);
    return heap;
}

void destroy_min_heap(MinHeap* heap) {
    free(heap->data);
    free(heap);
}

void heap_push(MinHeap* heap, int node, int cost) {
    if (heap->size == heap->capacity) {
        heap->capacity *= 2;
        heap->data = realloc(heap->data, sizeof(Edge) * heap->capacity);
    }
    heap->data[heap->size].node = node;
    heap->data[heap->size].cost = cost;
    int current = heap->size;
    int parent = (current - 1) / 2;
    while (heap->data[current].cost < heap->data[parent].cost) {
        Edge tmp = heap->data[current];
        heap->data[current] = heap->data[parent];
        heap->data[parent] = tmp;
        current = parent;
        parent = (current - 1) / 2;
    }
    heap->size++;
}

Edge heap_pop(MinHeap* heap) {
    Edge result = heap->data[0];
    heap->size--;
    if (heap->size > 0) {
        heap->data[0] = heap->data[heap->size];
        int current = 0;
        while (1) {
            int left_child = 2 * current + 1;
            int right_child = 2 * current + 2;
            int min_child = current;
            if (left_child < heap->size &&
                heap->data[left_child].cost < heap->data[min_child].cost) {
                min_child = left_child;
            }
            if (right_child < heap->size &&
                heap->data[right_child].cost < heap->data[min_child].cost) {
                min_child = right_child;
            }
            if (min_child != current) {
                Edge tmp
